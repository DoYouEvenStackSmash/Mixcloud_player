<!DOCTYPE HTML>
<html>
<head>
<script>
	// This is designed to play specific songs from mixcloud...
	// I know i overuse loops and i should just be using indexes of the PLAYLIST_SONGS as keys, but i have future plans that might not allow that to be used.

	var PLAYER_HISTORY_STACK = [];
	var TIMESTAMPS = {};
	var PLAYLIST_SONGS = [];
	async function update_playlist_songs() {
		// custom func for filling PLAYLIST_SONGS with whatever you want
		
		// my func will do Podcasts #600+ RONS and 382
		const ronsreg = /RONS.*?Podcast.*?\d{3,4}/i; //([6]\d{2}|\d{4,}|3[7-0][0-9])/i;
		var search_queue = ["https://api.mixcloud.com/search/?limit=100&q=rons%20podcast%20%23&type=cloudcast"];
		while (search_queue.length > 0) {
			var search_url = search_queue.pop();
			var search_results = await get_JSON(search_url);
			if ('data' in search_results) {
				for (var i in search_results['data']) {
					let m;
					if ((m = ronsreg.exec(search_results['data'][i]['name'])) !== null) {
						PLAYLIST_SONGS.push({
							name:search_results['data'][i]['name'],
							key:search_results['data'][i]['key']
							});
					}
					
				}
			}
			if ('paging' in search_results) {
				if ('next' in search_results['paging']) {
					search_queue.push(search_results['paging']['next'])
				}
			}
		}
		// REMOVE BAD SONGS
		var BAD_SONGS = ['/therealrons/rons-podcast-665/','RONS Podcast #160']; 	// EXAMPLE VALUES, EDIT THIS AS WE SEE FIT
		
		var i = PLAYLIST_SONGS.length - 1;
		while (i >= 0) {
			if (PLAYLIST_SONGS[i].name in BAD_SONGS || PLAYLIST_SONGS[i].key in BAD_SONGS) {
				PLAYLIST_SONGS = PLAYLIST_SONGS.splice(i, 1);
			} 
			i -= 1;
		}

		// TODO: GET AUDIO KEYS FOR EACH ITEM WHEN?
		console.log('done upadting my song playlist');
		return true;
	}
	async function find_songs(reg){
		var results = [];
		for (var record in PLAYLIST_SONGS) {
			var url = `https://api.mixcloud.com${PLAYLIST_SONGS[record].key}`;
			var data = await get_JSON(url);
			if (data.description) {
				let m;
				if ((m = reg.exec(data.description)) !== null) {
					results.push(PLAYLIST_SONGS[record]);
				}
			}
		}
		console.log('done');
		return results;
	}
	async function get_JSON(url) { let response = await fetch(url); let data = await response.json(); return data; }
	
	// this was working at one point, then they implemented cors issues so i had to go thru justcors.com
	async function retreive_audio_src2(key) { return JSON.parse(await (await fetch(`https://www.dlmixcloud.com/ajax.php/?url=https://www.mixcloud.com${key}`)).text())['url']; }

	async function retreive_audio_src(key) { 
		var url = `https://justcors.com/l_n1ehx3zipc/https://www.dlmixcloud.com/ajax.php/?url=https://www.mixcloud.com${key}`;
		var response = await fetch(url)
		var result_text = await response.text()
		var resulting_json = JSON.parse(result_text)
		var value = resulting_json['url'];
		return value;
	}

	function get_random_song_idx(){
		// Loads a random song index from the playlist queue, tries to not replay the last DONT_REPLAY_FROM_THE_LAST_X_SONGS songs.
		const DONT_REPLAY_FROM_THE_LAST_X_SONGS = 5;
		var r = Math.floor(Math.random() * PLAYLIST_SONGS.length);
		if (PLAYER_HISTORY_STACK.length < DONT_REPLAY_FROM_THE_LAST_X_SONGS) {
			// no option to play a diff song.
			return r;
		}
		while (r in PLAYER_HISTORY_STACK.slice(-DONT_REPLAY_FROM_THE_LAST_X_SONGS)) {
			r = Math.floor(Math.random() * PLAYLIST_SONGS.length);
		}
		return r;
	}
	function get_next_song_idx(){
		// Loads up the next song from the playlist queue.
		if (PLAYER_HISTORY_STACK.length == 0) {
			// no option to play a diff song.
			return 0;
		}
		return (PLAYER_HISTORY_STACK[0] + 1) % PLAYLIST_SONGS.length;
	}
	function mark_favorited_timestamp(){
		// adds a way to mark down timestamps of specific songs so that we can keep track of favorite songs etc.
		var audio = document.querySelector('audio');
		var curr_timestamp = audio.currentTime;	
		var curr_song = PLAYLIST_SONGS[PLAYER_HISTORY_STACK[0]];
		var timestamp_list = document.querySelector('#timestamps_list');
		var li = document.createElement("li");
		li.innerText = `${curr_song.name} @ ${sec_to_human_readable_timestamp(curr_timestamp)}`;
		timestamp_list.appendChild(li);
	}
	function sec_to_human_readable_timestamp(sec) {
		return `${String(parseInt(sec/3600)).padStart(2, '0')}:${String(parseInt((sec % 3600)/60)).padStart(2, '0')}:${parseInt(sec) % 60}`;
	}
	function load_selected_song(){
		var selected_val = document.querySelector('select').value;
		var i = 0;
		while (i < PLAYLIST_SONGS.length) {
			if (PLAYLIST_SONGS[i].key == selected_val) {
				load_song_from_index(i);
				return;
			}
			++i;
		}
	}
	/**
	 * PREREQ: update_playlist_songs has been run
	 * @param next_song, <int> the index from the PLAYLIST_SONGS to use, <null>=0, <str> the song key from the PLAYLIST_SONGS to use.
	 */
	async function load_song_from_index(next_song=null){
		if (PLAYLIST_SONGS.length == 0) {
			return;
		}
		// is run when we want to start loading a new song into the player
		if (typeof(next_song) == 'number') {
			next_song = (parseInt(next_song) || 0) % PLAYLIST_SONGS.length;
		} else if (typeof(next_song) == 'string') {
			var s = next_song;
			next_song = 0;
			while (next_song < PLAYLIST_SONGS.length) {
				if (PLAYLIST_SONGS[next_song].name == s || PLAYLIST_SONGS[next_song].key == s) {
					break
				}
				++next_song;
			}
			if (next_song == PLAYLIST_SONGS.length) {
				next_song = get_random_song_idx();
			}
		} else {
			next_song = document.querySelector('#shuffle_button').innerText == "üîÄ" ? get_random_song_idx() : get_next_song_idx();
		}
		// now next_song is an int.
		if (PLAYLIST_SONGS[next_song].src == undefined) {
			PLAYLIST_SONGS[next_song].src = await retreive_audio_src(PLAYLIST_SONGS[next_song].key);
		}
		
		// now we have the src for this song... its ready to be loaded
		await update_player_src(PLAYLIST_SONGS[next_song].src);
		// TODO: UPDATE UI
		// set currently playing in player history
		PLAYER_HISTORY_STACK.splice(0, 0, next_song);
		var dropdown_selections = document.getElementById('songlist_selector');
		dropdown_selections.value = PLAYLIST_SONGS[next_song].key;

		// update played history tab
		update_played_history_ui();
	}

	function update_played_history_ui() {
		var history_list = document.querySelector('#played_history_list');
		var ul = document.createElement("ul");
		ul.setAttribute('id','played_history_list');
		PLAYER_HISTORY_STACK.forEach(e=>{
			var li = document.createElement("li"); 
			li.innerText = `${PLAYLIST_SONGS[e].name}`;
			ul.appendChild(li);
		});
		history_list.innerHTML = ul.innerHTML;
	}
	/**
	 * @param src: <str> the audio source string to be played
	 */
	async function update_player_src(src) {
		// TODO update our players src
		var audio = document.querySelector('audio');
		var source = document.querySelector('source');
		if (!source) { source = document.createElement('source'); }
		source.setAttribute('src', src);
		audio.load();
		try{audio.play();audio.muted = false;}catch(err){}
	}

	function update_dropdown_with_current_songs(){
		// TODO: SORT BY PLAYLIST_SONGS?
		var i = 0;
		var dropdown_selections = document.getElementById('songlist_selector').options;
		while (dropdown_selections.length > 0) {
			dropdown_selections[0].remove();
		}
		// Sort by name, then by key
		PLAYLIST_SONGS.sort((a,b) => (a.name > b.name) ? 1 : ((b.name > a.name) ? -1 : (a.key > b.key) ? 1 : ((b.key > a.key) ? -1 : 0)));
		while (i < PLAYLIST_SONGS.length) {
			dropdown_selections.add(new Option(PLAYLIST_SONGS[i].name,PLAYLIST_SONGS[i].key));
			++i;
		}
		
	}

	

	window.onload = async function() {
		document.querySelector('audio').addEventListener('ended',load_song_from_index(get_random_song_idx()),false);
		document.querySelector('audio').addEventListener('pause',function(){if (document.querySelector('audio').currentTime >= document.querySelector('audio').duration - 1) {load_song_from_index()}},false);
		document.querySelector('#shuffle_button').addEventListener('click',function(){document.querySelector('#shuffle_button').innerText = document.querySelector('#shuffle_button').innerText == "üîÄ" ? "üîÉ" : "üîÄ"}, false);
		await update_playlist_songs();
		update_dropdown_with_current_songs();
		load_song_from_index(get_random_song_idx());
	}
</script>
</head>
<body>
	<h4>
		Currently playing:&nbsp;<select id="songlist_selector" onchange="load_selected_song()"><option>Loading...</option></select>
		&nbsp;<button id="shuffle_button" >üîÄ</button>
		&nbsp;<button id="skip" onclick="load_song_from_index()">‚è≠</button>
		&nbsp;<button id="mark_timestamp" onclick="mark_favorited_timestamp()">‚≠ê</button>

	</h4>
	<audio controls autoplay id="player" height="55px" style="width:90%"><source src="" type="audio/mp4" id="player_source"></audio>
	<h4>Played history:</h4>
	<ul id="played_history_list"></ul>
	<p>TIMESTAMPS:</p>
	<ul id="timestamps_list"></ul>
</body>
</html>
